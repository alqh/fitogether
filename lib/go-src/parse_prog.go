package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	"fitogether/golang"
	"fitogether/types"
	"fitogether/types/types_parser"
)

// FitogetherParseProg handles parsing tests results generated by a language to extract cFit validations. It produces an output for fitogether tool.
type FitogetherParseProg struct {
	pgLang          string
	testOutputPath  string
	parseOutputPath string
}

func (p FitogetherParseProg) Validate() error {
	if p.pgLang == "" {
		return errors.New("-l is required")
	}

	if p.testOutputPath == "" {
		return errors.New("-f is required")
	}
	return nil
}

func (p FitogetherParseProg) Run() error {
	parseOutputPath := p.parseOutputPath
	parseOutputPath = p.defaultParseOutputPath(parseOutputPath, p.pgLang)

	var psr types_parser.LangParser
	switch p.pgLang {
	case "go":
		psr = golang.NewGoLangParser()
	}

	extracted, err := psr.ExtractFitTest(p.testOutputPath)
	if err != nil {
		return fmt.Errorf("unable to parse tests output %v", err)
	}

	out, err := p.convertTestResultToOutput(extracted)
	if err != nil {
		return fmt.Errorf("unable to convert tests result to output %v", err)
	}

	val, err := json.Marshal(out)
	if err != nil {
		return fmt.Errorf("failed to write output parsed %v", err)
	}

	if err := os.WriteFile(parseOutputPath, val, 0644); err != nil {
		return fmt.Errorf("failed to write output parsed %v", err)
	}

	return nil
}

// defaultParseOutputPath returns the default output path given a program language.
func (p FitogetherParseProg) defaultParseOutputPath(parseOutputPath string, pgLang string) string {
	if parseOutputPath == "" {
		return fmt.Sprintf("%s_fitogether.json", pgLang)
	} else if !strings.HasSuffix(parseOutputPath, ".json") {
		return fmt.Sprintf("%s/%s_fitogether.json", parseOutputPath, pgLang)
	}

	return parseOutputPath
}

func (p FitogetherParseProg) convertTestResultToOutput(results []types_parser.FitTestResult) ([]types.FitogetherOutput, error) {
	out := make([]types.FitogetherOutput, 0, len(results))
	for _, r := range results {
		var ts types.TestResultType
		switch r.TestResult() {
		case types_parser.TestResultState_PASS:
			ts = types.TestResultTypePass
		case types_parser.TestResultState_FAIL:
			ts = types.TestResultTypeFail
		case types_parser.TestResultState_SKIP:
			ts = types.TestResultTypeSkip
		default:
			return nil, fmt.Errorf("unknown tests result %v", r.TestResult())
		}

		out = append(out, types.FitogetherOutput{
			TestName:       r.TestName(),
			TestPath:       r.TestPath(),
			FitExpectation: r.FitExpectation(),
			TestResult:     ts,
			RanAt:          r.RanAt(),
		})
	}
	return out, nil
}
